netcdf output_state_2060 {
dimensions:
	StrLen = 64 ;
	Time = UNLIMITED ; // (1 currently)
	nCells = 385379 ;
	nVertInterfaces = 6 ;
	nEdges = 1161656 ;
	nVertices = 776277 ;
	TWO = 2 ;
	maxEdges = 9 ;
	maxEdges2 = 18 ;
	vertexDegree = 3 ;
	nVertLevels = 5 ;
variables:
	char xtime(Time, StrLen) ;
		xtime:units = "unitless" ;
		xtime:long_name = "model time, with format \'YYYY-MM-DD_HH:MM:SS\'" ;
	char simulationStartTime(StrLen) ;
		simulationStartTime:units = "unitless" ;
		simulationStartTime:long_name = "start time of first simulation, with format \'YYYY-MM-DD_HH:MM:SS\'" ;
	double thickness(Time, nCells) ;
		thickness:units = "m" ;
		thickness:long_name = "ice thickness" ;
	double bedTopography(Time, nCells) ;
		bedTopography:units = "m above datum" ;
		bedTopography:long_name = "Elevation of ice sheet bed.  Once isostasy is added to the model, this should become a state variable." ;
	double uReconstructX(Time, nCells, nVertInterfaces) ;
		uReconstructX:units = "m s^{-1}" ;
		uReconstructX:long_name = "x-component of velocity reconstructed on cell centers.  Also, for higher-order dycores, on input: value of the x-component of velocity that should be applied where dirichletVelocityMask==1." ;
	double uReconstructY(Time, nCells, nVertInterfaces) ;
		uReconstructY:units = "m s^{-1}" ;
		uReconstructY:long_name = "y-component of velocity reconstructed on cell centers.    Also, for higher-order dycores, on input: value of the y-component of velocity that should be applied where dirichletVelocityMask==1." ;
	double basalTemperature(Time, nCells) ;
		basalTemperature:units = "K" ;
		basalTemperature:long_name = "temperature at lower ice surface" ;
	double daysSinceStart(Time) ;
		daysSinceStart:units = "days" ;
		daysSinceStart:long_name = "Time since simulationStartTime in days, for plotting" ;
	int cellProcID(nCells) ;
		cellProcID:units = "unitless" ;
		cellProcID:long_name = "processor number for each cell" ;
	int cellMask(Time, nCells) ;
		cellMask:units = "none" ;
		cellMask:long_name = "bitmask indicating various properties about the ice sheet on cells.  cellMask only needs to be a restart field if config_allow_additional_advance = false (to keep the mask of initial ice extent)" ;
	double deltat(Time) ;
		deltat:units = "s" ;
		deltat:long_name = "time step length, in seconds.  Value on a given time is the value used between the previous time level and the current time level." ;
	double waterThickness(Time, nCells) ;
		waterThickness:units = "m" ;
		waterThickness:long_name = "water layer thickness in subglacial hydrology system" ;
	double waterPressure(Time, nCells) ;
		waterPressure:units = "Pa" ;
		waterPressure:long_name = "pressure in subglacial hydrology system" ;
	double basalMeltInput(Time, nCells) ;
		basalMeltInput:units = "kg m^{-2} s^{-1}" ;
		basalMeltInput:long_name = "basal meltwater input to subglacial hydrology system" ;
	double effectivePressure(Time, nCells) ;
		effectivePressure:units = "Pa" ;
		effectivePressure:long_name = "effective ice pressure in subglacial hydrology system" ;
	double waterFlux(Time, nEdges) ;
		waterFlux:units = "m{^2} s^{-1}" ;
		waterFlux:long_name = "total water flux in subglacial hydrology system" ;
	double hydropotential(Time, nCells) ;
		hydropotential:units = "Pa" ;
		hydropotential:long_name = "hydropotential in subglacial hydrology system" ;
	double waterVelocity(Time, nEdges) ;
		waterVelocity:units = "m s^{-1}" ;
		waterVelocity:long_name = "water velocity in subglacial hydrology system" ;
	double basalFrictionFlux(Time, nCells) ;
		basalFrictionFlux:units = "W m^{-2}" ;
		basalFrictionFlux:long_name = "basal frictional heat flux into the ice (positive upward)" ;
	double basalHeatFlux(Time, nCells) ;
		basalHeatFlux:units = "W m^{-2}" ;
		basalHeatFlux:long_name = "basal heat flux into the ice (positive upward)" ;
	double waterVelocityCellX(Time, nCells) ;
		waterVelocityCellX:units = "m s^{-1}" ;
		waterVelocityCellX:long_name = "subglacial water velocity reconstructed on cell centers, x-component" ;
	double waterVelocityCellY(Time, nCells) ;
		waterVelocityCellY:units = "m s^{-1}" ;
		waterVelocityCellY:long_name = "subglacial water velocity reconstructed on cell centers, y-component" ;
	int hydroMarineMarginMask(Time, nEdges) ;
		hydroMarineMarginMask:units = "none" ;
		hydroMarineMarginMask:long_name = "mask indicating the marine boundary of the active subglacial hydrology domain" ;
	int hydroTerrestrialMarginMask(Time, nEdges) ;
		hydroTerrestrialMarginMask:units = "none" ;
		hydroTerrestrialMarginMask:long_name = "mask indicating the terrestrial boundary of the active subglacial hydrology domain" ;
	int waterFluxMask(Time, nEdges) ;
		waterFluxMask:units = "none" ;
		waterFluxMask:long_name = "mask indicating how to handle fluxes on each edge: 0=calculate based on hydropotential gradient; 1=allow outflow based on hydropotential gradient, but no inflow (NOT YET IMPLEMENTED); 2=zero flux" ;
	double totalGroundingLineDischargeCell(Time, nCells) ;
		totalGroundingLineDischargeCell:units = "m^{3} s^{-1}" ;
		totalGroundingLineDischargeCell:long_name = "total discharge across the grounding line, extrapolated from edge to adjacent ungrounded cell" ;
	double diffusivity(Time, nEdges) ;
		diffusivity:units = "m^{2} s^{-1}" ;
		diffusivity:long_name = "diffusivity of water sheet in subglacial hydrology system" ;
	double latCell(nCells) ;
		latCell:units = "radians" ;
		latCell:long_name = "Latitude location of cell centers in radians." ;
	double lonCell(nCells) ;
		lonCell:units = "radians" ;
		lonCell:long_name = "Longitude location of cell centers in radians." ;
	double xCell(nCells) ;
		xCell:units = "unitless" ;
		xCell:long_name = "X Coordinate in cartesian space of cell centers." ;
	double yCell(nCells) ;
		yCell:units = "unitless" ;
		yCell:long_name = "Y Coordinate in cartesian space of cell centers." ;
	double zCell(nCells) ;
		zCell:units = "unitless" ;
		zCell:long_name = "Z Coordinate in cartesian space of cell centers." ;
	int indexToCellID(nCells) ;
		indexToCellID:units = "unitless" ;
		indexToCellID:long_name = "List of global cell IDs." ;
	double latEdge(nEdges) ;
		latEdge:units = "radians" ;
		latEdge:long_name = "Latitude location of edge midpoints in radians." ;
	double lonEdge(nEdges) ;
		lonEdge:units = "radians" ;
		lonEdge:long_name = "Longitude location of edge midpoints in radians." ;
	double xEdge(nEdges) ;
		xEdge:units = "unitless" ;
		xEdge:long_name = "X Coordinate in cartesian space of edge midpoints." ;
	double yEdge(nEdges) ;
		yEdge:units = "unitless" ;
		yEdge:long_name = "Y Coordinate in cartesian space of edge midpoints." ;
	double zEdge(nEdges) ;
		zEdge:units = "unitless" ;
		zEdge:long_name = "Z Coordinate in cartesian space of edge midpoints." ;
	int indexToEdgeID(nEdges) ;
		indexToEdgeID:units = "unitless" ;
		indexToEdgeID:long_name = "List of global edge IDs." ;
	double latVertex(nVertices) ;
		latVertex:units = "radians" ;
		latVertex:long_name = "Latitude location of vertices in radians." ;
	double lonVertex(nVertices) ;
		lonVertex:units = "radians" ;
		lonVertex:long_name = "Longitude location of vertices in radians." ;
	double xVertex(nVertices) ;
		xVertex:units = "unitless" ;
		xVertex:long_name = "X Coordinate in cartesian space of vertices." ;
	double yVertex(nVertices) ;
		yVertex:units = "unitless" ;
		yVertex:long_name = "Y Coordinate in cartesian space of vertices." ;
	double zVertex(nVertices) ;
		zVertex:units = "unitless" ;
		zVertex:long_name = "Z Coordinate in cartesian space of vertices." ;
	int indexToVertexID(nVertices) ;
		indexToVertexID:units = "unitless" ;
		indexToVertexID:long_name = "List of global vertex IDs." ;
	int cellsOnEdge(nEdges, TWO) ;
		cellsOnEdge:units = "unitless" ;
		cellsOnEdge:long_name = "List of cells that straddle each edge." ;
	int nEdgesOnCell(nCells) ;
		nEdgesOnCell:units = "unitless" ;
		nEdgesOnCell:long_name = "Number of edges that border each cell." ;
	int nEdgesOnEdge(nEdges) ;
		nEdgesOnEdge:units = "unitless" ;
		nEdgesOnEdge:long_name = "Number of edges that surround each of the cells that straddle each edge. These edges are used to reconstruct the tangential velocities." ;
	int edgesOnCell(nCells, maxEdges) ;
		edgesOnCell:units = "unitless" ;
		edgesOnCell:long_name = "List of edges that border each cell." ;
	int edgesOnEdge(nEdges, maxEdges2) ;
		edgesOnEdge:units = "unitless" ;
		edgesOnEdge:long_name = "List of edges that border each of the cells that straddle each edge." ;
	double weightsOnEdge(nEdges, maxEdges2) ;
		weightsOnEdge:units = "unitless" ;
		weightsOnEdge:long_name = "Reconstruction weights associated with each of the edgesOnEdge." ;
	double dvEdge(nEdges) ;
		dvEdge:units = "m" ;
		dvEdge:long_name = "Length of each edge, computed as the distance between verticesOnEdge." ;
	double dcEdge(nEdges) ;
		dcEdge:units = "m" ;
		dcEdge:long_name = "Length of each edge, computed as the distance between cellsOnEdge." ;
	double angleEdge(nEdges) ;
		angleEdge:units = "radians" ;
		angleEdge:long_name = "Angle the edge normal makes with local eastward direction." ;
	double areaCell(nCells) ;
		areaCell:units = "m^2" ;
		areaCell:long_name = "Area of each cell in the primary grid." ;
	double areaTriangle(nVertices) ;
		areaTriangle:units = "m^2" ;
		areaTriangle:long_name = "Area of each cell (triangle) in the dual grid." ;
	int cellsOnCell(nCells, maxEdges) ;
		cellsOnCell:units = "unitless" ;
		cellsOnCell:long_name = "List of cells that neighbor each cell." ;
	int verticesOnCell(nCells, maxEdges) ;
		verticesOnCell:units = "unitless" ;
		verticesOnCell:long_name = "List of vertices that border each cell." ;
	int verticesOnEdge(nEdges, TWO) ;
		verticesOnEdge:units = "unitless" ;
		verticesOnEdge:long_name = "List of vertices that straddle each edge." ;
	int edgesOnVertex(nVertices, vertexDegree) ;
		edgesOnVertex:units = "unitless" ;
		edgesOnVertex:long_name = "List of edges that share a vertex as an endpoint." ;
	int cellsOnVertex(nVertices, vertexDegree) ;
		cellsOnVertex:units = "unitless" ;
		cellsOnVertex:long_name = "List of cells that share a vertex." ;
	double kiteAreasOnVertex(nVertices, vertexDegree) ;
		kiteAreasOnVertex:units = "m^2" ;
		kiteAreasOnVertex:long_name = "Area of the portions of each dual cell that are part of each cellsOnVertex." ;
	double layerThicknessFractions(nVertLevels) ;
		layerThicknessFractions:units = "none" ;
		layerThicknessFractions:long_name = "Fractional thickness of each sigma layer" ;
	double meshDensity(nCells) ;
		meshDensity:units = "unitless" ;
		meshDensity:long_name = "The value of the generating density function at each cell center." ;

// global attributes:
		:model_name = "mpas" ;
		:core_name = "landice" ;
		:source = "MPAS" ;
		:Conventions = "MPAS" ;
		:git_version = "v2.0.0-beta.3-33691-g0dbb0fb1ff" ;
		:on_a_sphere = "NO" ;
		:sphere_radius = 0. ;
		:is_periodic = "NO" ;
		:x_period = 0. ;
		:y_period = 0. ;
		:history = "mpirun -n 128 ./landice_model" ;
		:parent_id = "tnvuursulf\n",
			"27h8c35xff\n",
			"jzt8a2gxaf\n",
			"y808v7bkix\n",
			"lclrmiizwz\n",
			"pmtzb5h15d\n",
			"sjrc424ult\n",
			"t28yfwmmtg\n",
			"kqf6psc1jw" ;
		:mesh_spec = "1.0" ;
		:config_velocity_solver = "none" ;
		:config_sia_tangent_slope_calculation = "from_vertex_barycentric" ;
		:config_flowParamA_calculation = "constant" ;
		:config_do_velocity_reconstruction_for_external_dycore = "NO" ;
		:config_simple_velocity_type = "uniform" ;
		:config_use_glp = "YES" ;
		:config_beta_thawed_only = "NO" ;
		:config_unrealistic_velocity = 0.00159 ;
		:config_nonconvergence_error = "NO" ;
		:config_effective_pressure_max = 1.e+36 ;
		:config_thickness_advection = "none" ;
		:config_tracer_advection = "none" ;
		:config_horiz_tracer_adv_order = 3 ;
		:config_advection_coef_3rd_order = 0.25 ;
		:config_restore_thickness_after_advection = "NO" ;
		:config_zero_sfcMassBalApplied_over_bare_land = "YES" ;
		:config_uplift_method = "none" ;
		:config_slm_coupling_interval = 2 ;
		:config_MALI_to_SLM_weights_file = "mpas_to_grid.nc" ;
		:config_SLM_to_MALI_weights_file = "grid_to_mpas.nc" ;
		:config_calving = "none" ;
		:config_apply_calving_mask = "NO" ;
		:config_use_Albany_flowA_eqn_for_vM = "NO" ;
		:config_calving_topography = -500. ;
		:config_calving_thickness = 0. ;
		:config_calving_eigencalving_parameter_source = "scalar" ;
		:config_calving_eigencalving_parameter_scalar_value = 3.14e+16 ;
		:config_calving_specified_source = "const" ;
		:config_calving_velocity_const = 0. ;
		:config_data_calving = "NO" ;
		:config_calving_timescale = 0. ;
		:config_restore_calving_front = "YES" ;
		:config_restore_calving_front_prevent_retreat = "NO" ;
		:config_remove_icebergs = "YES" ;
		:config_remove_small_islands = "YES" ;
		:config_calving_speed_limit = 0.00063492063 ;
		:config_grounded_von_Mises_threshold_stress = 1000000. ;
		:config_floating_von_Mises_threshold_stress = 1000000. ;
		:config_grounded_von_Mises_threshold_stress_source = "scalar" ;
		:config_floating_von_Mises_threshold_stress_source = "scalar" ;
		:config_finalize_damage_after_advection = "YES" ;
		:config_preserve_damage = "NO" ;
		:config_calculate_damage = "YES" ;
		:config_damage_preserve_threshold = 0. ;
		:config_damage_calving_threshold = 0.95 ;
		:config_damage_stiffness_min = 0.1 ;
		:config_damage_rheology_coupling = "NO" ;
		:config_damage_gl_setting = "nye" ;
		:config_damage_calving_method = "none" ;
		:config_damagecalvingParameter = 0.0001 ;
		:config_ismip6_retreat_k = -170. ;
		:config_calving_error_threshold = 100000. ;
		:config_distribute_unablatedVolumeDynCell = "YES" ;
		:config_update_velocity_before_calving = "NO" ;
		:config_thermal_solver = "none" ;
		:config_thermal_calculate_bmb = "YES" ;
		:config_temperature_init = "file" ;
		:config_thermal_thickness = 0. ;
		:config_surface_air_temperature_source = "file" ;
		:config_surface_air_temperature_value = 273.15 ;
		:config_surface_air_temperature_lapse_rate = 0.01 ;
		:config_basal_heat_flux_source = "file" ;
		:config_basal_heat_flux_value = 0. ;
		:config_temp_diffusive_factor = 1.e-05 ;
		:config_max_water_fraction = 0.01 ;
		:config_basal_mass_bal_float = "none" ;
		:config_bmlt_float_flux = 0. ;
		:config_bmlt_float_xlimit = 0. ;
		:config_basal_mass_bal_seroussi_amplitude = 0. ;
		:config_basal_mass_bal_seroussi_period = 1. ;
		:config_basal_mass_bal_seroussi_phase = 0. ;
		:config_temperature_profile_melt_scale_factor = 6. ;
		:config_temperature_profile_sill_elevation = -700. ;
		:config_temperature_profile_plume_thickness = 30. ;
		:config_temperature_profile_draft_slope = 0.01 ;
		:config_temperature_profile_thermocline_upper_depth = -200. ;
		:config_temperature_profile_thermocline_upper_temp = -1. ;
		:config_temperature_profile_thermocline_lower_depth = -600. ;
		:config_temperature_profile_thermocline_lower_temp = 1.2 ;
		:config_temperature_profile_variability_amplitude = 0. ;
		:config_temperature_profile_variability_period = 1. ;
		:config_temperature_profile_variability_phase = 0. ;
		:config_temperature_profile_GL_depth_fraction = 0.25 ;
		:config_front_mass_bal_grounded = "none" ;
		:config_use_3d_thermal_forcing_for_face_melt = "YES" ;
		:config_beta_ocean_thermal_forcing = 1.18 ;
		:config_add_ocean_thermal_forcing = 0. ;
		:config_alpha_subglacial_discharge = 0.39 ;
		:config_subglacial_discharge_coefficient = 0.0003 ;
		:config_subglacial_discharge_intercept = 0.15 ;
		:config_uniform_face_melt_rate = 0. ;
		:config_ice_density = 910. ;
		:config_ocean_density = 1028. ;
		:config_sea_level = 0. ;
		:config_default_flowParamA = 3.1709792e-24 ;
		:config_flowLawExponent = 3. ;
		:config_dynamic_thickness = 10. ;
		:config_dt = "0001-00-00_00:00:00" ;
		:config_time_integration = "forward_euler" ;
		:config_rk_order = 2 ;
		:config_rk3_stages = 3 ;
		:config_adaptive_timestep = "NO" ;
		:config_min_adaptive_timestep = 60. ;
		:config_max_adaptive_timestep = 31540000. ;
		:config_adaptive_timestep_CFL_fraction = 0.8 ;
		:config_adaptive_timestep_calvingCFL_fraction = 0.8 ;
		:config_adaptive_timestep_faceMeltingCFL_fraction = 1. ;
		:config_adaptive_timestep_include_DCFL = "NO" ;
		:config_adaptive_timestep_include_calving = "NO" ;
		:config_adaptive_timestep_include_face_melting = "NO" ;
		:config_adaptive_timestep_force_interval = "0001-00-00_00:00:00" ;
		:config_do_restart = "YES" ;
		:config_restart_timestamp_name = "restart_timestamp" ;
		:config_start_time = "file" ;
		:config_stop_time = "2060-01-01_00:00:00" ;
		:config_run_duration = "none" ;
		:config_calendar_type = "noleap" ;
		:config_stats_interval = 0 ;
		:config_write_stats_on_startup = "YES" ;
		:config_stats_cell_ID = 1 ;
		:config_write_output_on_startup = "YES" ;
		:config_pio_num_iotasks = 2 ;
		:config_pio_stride = 64 ;
		:config_year_digits = 4 ;
		:config_output_external_velocity_solver_data = "NO" ;
		:config_write_albany_ascii_mesh = "NO" ;
		:config_num_halos = 3 ;
		:config_block_decomp_file_prefix = "graph.info.part." ;
		:config_number_of_blocks = 0 ;
		:config_explicit_proc_decomp = "NO" ;
		:config_proc_decomp_file_prefix = "graph.info.part." ;
		:config_print_thickness_advection_info = "NO" ;
		:config_print_calving_info = "NO" ;
		:config_print_thermal_info = "NO" ;
		:config_always_compute_fem_grid = "YES" ;
		:config_print_velocity_cleanup_details = "NO" ;
		:config_check_tracer_monotonicity = "NO" ;
		:config_SGH = "YES" ;
		:config_ocean_connection_N = "NO" ;
		:config_SGH_adaptive_timestep_fraction = 1. ;
		:config_SGH_max_adaptive_timestep = 3150000000. ;
		:config_SGH_tangent_slope_calculation = "from_normal_slope" ;
		:config_SGH_pressure_calc = "cavity" ;
		:config_SGH_alpha = 1.25 ;
		:config_SGH_beta = 1.5 ;
		:config_SGH_conduc_coeff = 0.001 ;
		:config_SGH_conduc_coeff_drowned = 0. ;
		:config_SGH_till_drainage = 0. ;
		:config_SGH_till_max = 0. ;
		:config_SGH_advection = "fo" ;
		:config_SGH_bed_roughness = 0.5 ;
		:config_SGH_bed_roughness_max = 0.1 ;
		:config_SGH_creep_coefficient = 0.04 ;
		:config_SGH_englacial_porosity = 0.01 ;
		:config_SGH_chnl_active = "NO" ;
		:config_SGH_chnl_include_DCFL = "NO" ;
		:config_SGH_chnl_alpha = 1.25 ;
		:config_SGH_chnl_beta = 1.5 ;
		:config_SGH_chnl_conduc_coeff = 0.1 ;
		:config_SGH_chnl_creep_coefficient = 0.04 ;
		:config_SGH_incipient_channel_width = 2. ;
		:config_SGH_include_pressure_melt = "NO" ;
		:config_SGH_shmip_forcing = "none" ;
		:config_SGH_basal_melt = "basal_heat" ;
		:config_AM_globalStats_enable = "YES" ;
		:config_AM_globalStats_compute_interval = "output_interval" ;
		:config_AM_globalStats_stream_name = "globalStatsOutput" ;
		:config_AM_globalStats_compute_on_startup = "YES" ;
		:config_AM_globalStats_write_on_startup = "YES" ;
		:config_AM_regionalStats_enable = "YES" ;
		:config_AM_regionalStats_compute_interval = "output_interval" ;
		:config_AM_regionalStats_stream_name = "regionalStatsOutput" ;
		:config_AM_regionalStats_compute_on_startup = "YES" ;
		:config_AM_regionalStats_write_on_startup = "YES" ;
		:file_id = "erinxa1vuf" ;
}
